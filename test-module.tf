# ▼▼▼ Automatically generated by Terraform SubmoduleTool, PLEASE DON'T EDIT MANUALLY :) ▼▼▼
locals{ 
mirror_maker = { 
max_tasks = coalesce(var.mirror_maker.max_tasks, 1) 
mirrormaker_version = coalesce(var.mirror_maker.mirrormaker_version, "3.1.0") 
replicas = coalesce(var.mirror_maker.replicas, 3) 
source_cluster_alias = coalesce(var.mirror_maker.source_cluster_alias, "source-cluster-alias") 
target_cluster_alias = coalesce(var.mirror_maker.target_cluster_alias, "target-cluster-alias") 
wait = coalesce(var.mirror_maker.wait, true) 
wait_for_rollout = coalesce(var.mirror_maker.wait_for_rollout, true) 


checkpointconnector_config = var.mirror_maker.checkpointconnector_config != null ? merge(var.mirror_maker.checkpointconnector_config,
tomap({ 
"checkpoints.topic.replication.factor" = contains(keys(var.mirror_maker.checkpointconnector_config),"checkpoints.topic.replication.factor") != false ? var.mirror_maker.checkpointconnector_config["checkpoints.topic.replication.factor"] : 1
"replication.policy.class" = contains(keys(var.mirror_maker.checkpointconnector_config),"replication.policy.class") != false ? var.mirror_maker.checkpointconnector_config["replication.policy.class"] : "org.apache.kafka.connect.mirror.IdentityReplicationPolicy"
"replication.policy.separator" = contains(keys(var.mirror_maker.checkpointconnector_config),"replication.policy.separator") != false ? var.mirror_maker.checkpointconnector_config["replication.policy.separator"] : ""}
)):{
 "checkpoints.topic.replication.factor" = 1
 "replication.policy.class" = "org.apache.kafka.connect.mirror.IdentityReplicationPolicy"
 "replication.policy.separator" = ""
} 
heartbeatconnector_config = var.mirror_maker.heartbeatconnector_config != null ? merge(var.mirror_maker.heartbeatconnector_config,
tomap({ 
"heartbeats.topic.replication.factor" = contains(keys(var.mirror_maker.heartbeatconnector_config),"heartbeats.topic.replication.factor") != false ? var.mirror_maker.heartbeatconnector_config["heartbeats.topic.replication.factor"] : 1}
)):{
 "heartbeats.topic.replication.factor" = 1
} 
sourceconnector_config = var.mirror_maker.sourceconnector_config != null ? merge(var.mirror_maker.sourceconnector_config,
tomap({ 
"offset-syncs.topic.replication.factor" = contains(keys(var.mirror_maker.sourceconnector_config),"offset-syncs.topic.replication.factor") != false ? var.mirror_maker.sourceconnector_config["offset-syncs.topic.replication.factor"] : 1
"replication.factor" = contains(keys(var.mirror_maker.sourceconnector_config),"replication.factor") != false ? var.mirror_maker.sourceconnector_config["replication.factor"] : 2
"replication.policy.class" = contains(keys(var.mirror_maker.sourceconnector_config),"replication.policy.class") != false ? var.mirror_maker.sourceconnector_config["replication.policy.class"] : "org.apache.kafka.connect.mirror.IdentityReplicationPolicy"
"replication.policy.separator" = contains(keys(var.mirror_maker.sourceconnector_config),"replication.policy.separator") != false ? var.mirror_maker.sourceconnector_config["replication.policy.separator"] : ""
"sync.topic.acls.enabled" = contains(keys(var.mirror_maker.sourceconnector_config),"sync.topic.acls.enabled") != false ? var.mirror_maker.sourceconnector_config["sync.topic.acls.enabled"] : "false"}
)):{
 "offset-syncs.topic.replication.factor" = 1
 "replication.factor" = 2
 "replication.policy.class" = "org.apache.kafka.connect.mirror.IdentityReplicationPolicy"
 "replication.policy.separator" = ""
 "sync.topic.acls.enabled" = "false"
} 
}

prometheous_stack = { 
atomic = coalesce(var.prometheous_stack.atomic, true) 
chart = coalesce(var.prometheous_stack.chart, "kube-prometheus-stack") 
chart_version = coalesce(var.prometheous_stack.chart_version, "33.0.0") 
cleanup_on_fail = coalesce(var.prometheous_stack.cleanup_on_fail, true) 
create_namespace = coalesce(var.prometheous_stack.create_namespace, true) 
create_resource = coalesce(var.prometheous_stack.create_resource, true) 
is_NodeExporter = coalesce(var.prometheous_stack.is_NodeExporter, true) 
name = coalesce(var.prometheous_stack.name, "kube-prometheus-stack") 
namespace = coalesce(var.prometheous_stack.namespace, "monitoring") 
repository = coalesce(var.prometheous_stack.repository, "https://prometheus-community.github.io/helm-charts") 
timeout = coalesce(var.prometheous_stack.timeout, 300) 
wait = coalesce(var.prometheous_stack.wait, true) 
wait_for_rollout = coalesce(var.prometheous_stack.wait_for_rollout, true) 


grafana_annotations = var.prometheous_stack.grafana_annotations != null ? merge(var.prometheous_stack.grafana_annotations,
tomap({ 
"consul.hashicorp.com/service-sync" = contains(keys(var.prometheous_stack.grafana_annotations),"consul.hashicorp.com/service-sync") != false ? var.prometheous_stack.grafana_annotations["consul.hashicorp.com/service-sync"] : "true"}
)):{
 "consul.hashicorp.com/service-sync" = "true"
} 
operator_annotations = var.prometheous_stack.operator_annotations != null ? merge(var.prometheous_stack.operator_annotations,
tomap({ 
"consul.hashicorp.com/service-sync" = contains(keys(var.prometheous_stack.operator_annotations),"consul.hashicorp.com/service-sync") != false ? var.prometheous_stack.operator_annotations["consul.hashicorp.com/service-sync"] : "true"}
)):{
 "consul.hashicorp.com/service-sync" = "true"
} 
}

storage_local_provisioner = { 
atomic = coalesce(var.storage_local_provisioner.atomic, true) 
chart = coalesce(var.storage_local_provisioner.chart, "vendors/provisioner") 
cleanup_on_fail = coalesce(var.storage_local_provisioner.cleanup_on_fail, true) 
create_local_storage_provisioner = coalesce(var.storage_local_provisioner.create_local_storage_provisioner, true) 
create_namespace = coalesce(var.storage_local_provisioner.create_namespace, true) 
local_provisioner_hostdir = coalesce(var.storage_local_provisioner.local_provisioner_hostdir, "/mnt") 
name = coalesce(var.storage_local_provisioner.name, "local-storage-provisioner") 
namespace = coalesce(var.storage_local_provisioner.namespace, "storage-provisioner") 
storage_class = coalesce(var.storage_local_provisioner.storage_class, "nvme-ssd") 
timeout = coalesce(var.storage_local_provisioner.timeout, 300) 
wait = coalesce(var.storage_local_provisioner.wait, true) 


}
}
